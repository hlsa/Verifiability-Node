interface FrankaArmControl {
setConfiguration (  )

	grip ( )
	releaseGrip ( )
}

interface DressingEvents {
	event snaggingDetected
	event invalidTrajectory

	event invalidPoseDetected
	event userInterrupt

	event poseDetected
	event dressingRequest

	event garmentDetected

	event armConfig

	event userPosition

event gripCorrect : boolean
	event gripperEngaged : boolean
event correctedMovement
event secondHandDetected
	event userDressed
}

interface SensorOperations {
	detectGarment ( )
detectUserPose ( )
checkFault ( )
detectSecondArm ( )
}

interface EmergencyStopEvents {
	event emergencyStop

	event resumeDressing
}

interface EnvironmentalEvents {
	event backgroundNoiseLevel : NoiseLevel
	event otherAgentDetected : boolean
}

enumeration NoiseLevel { High Medium Low } interface MovementEvents {
	event movementStart
	event movementEnd
}

interface HRIOperations {
	checkCorrectGrip ( )
checkUserDressed ( )
}

controller CDressingControl {
	uses DressingEvents requires FrankaArmControl sref stm_ref0 = SDressingControl
	connection CDressingControl on snaggingDetected to stm_ref0 on snaggingDetected
	connection CDressingControl on invalidTrajectory to stm_ref0 on invalidTrajectory
	connection CDressingControl on invalidPoseDetected to stm_ref0 on invalidPoseDetected
	connection CDressingControl on userInterrupt to stm_ref0 on userInterrupt
	connection CDressingControl on poseDetected to stm_ref0 on poseDetected
	connection CDressingControl on dressingRequest to stm_ref0 on dressingRequest
	connection CDressingControl on garmentDetected to stm_ref0 on garmentDetected
	connection CDressingControl on armConfig to stm_ref0 on armConfig
connection CDressingControl on userPosition to stm_ref0 on userPosition
requires SensorOperations sref stm_ref1 = SEmergencyStopControl

	connection CDressingControl on emergencyStop to stm_ref1 on emergencyStop
	connection CDressingControl on resumeDressing to stm_ref1 on resumeDressing

	connection stm_ref2 on environmentalResume to stm_ref1 on environmentalResume
	connection stm_ref2 on environmentalStop to stm_ref1 on environmentalStop
	connection CDressingControl on backgroundNoiseLevel to stm_ref2 on backgroundNoiseLevel
	connection CDressingControl on otherAgentDetected to stm_ref2 on otherAgentDetected
event dressedJoint : int
	connection stm_ref0 on dressedJoint to CDressingControl on dressedJoint
uses EmergencyStopEvents connection stm_ref1 on allowMovement to stm_ref3 on allowMovement

	event atTarget : boolean
	uses EnvironmentalEvents sref stm_ref2 = EnvironmentalMonitor

	connection stm_ref0 on movementStart to stm_ref3 on movementStart
	connection stm_ref3 on movementEnd to stm_ref0 on movementEnd
requires HRIOperations
	sref stm_ref3 = MovementControl
	connection CDressingControl on gripperEngaged to stm_ref0 on gripperEngaged
	connection CDressingControl on gripCorrect to stm_ref0 on gripCorrect
	connection CDressingControl on atTarget to stm_ref3 on atTarget
connection stm_ref0 on correctedMovement to CDressingControl on correctedMovement
connection CDressingControl on secondHandDetected to stm_ref0 on secondHandDetected
connection CDressingControl on userDressed to stm_ref0 on userDressed
}

stm SDressingControl {
	initial i0
uses DressingEvents requires FrankaArmControl 
	
	var currentJoint : int = 2
	state GarmentAcquisition {
		state LookingForGarment {
			entry detectGarment ( )
		}
		initial i0

		state EngageGarment {
			entry grip ( )
		}
		transition t0 {
			from i0
			to LookingForGarment
		}
		transition t1 {
			from LookingForGarment
			to Moving
			trigger 
		
		garmentDetected
			action movementStart
		}

		transition t5 {
			from j0
			to f0
		condition isGripCorrect
			action garmentAcquired = true
		}
	state Moving {
		}
		final f0

		transition t2 {
			from Moving
			to EngageGarment
			trigger movementEnd
		}
	state confirmGripCorrect {
			entry checkCorrectGrip ( )
		}
		junction j0
		junction j1
		transition t3 {
			from confirmGripCorrect
			to j0
			trigger gripCorrect ? isGripCorrect
		}
		transition t4 {
			from EngageGarment
			to j1
			trigger gripperEngaged ? isGripperEngaged
		}
		transition t6 {
			from j1
			to LookingForGarment
			condition not isGripperEngaged
		}
		transition t7 {
			from j0
			to LookingForGarment
			condition not isGripCorrect
			action releaseGrip ( )
		}
		transition t8 {
			from j1
			to confirmGripCorrect
			condition isGripperEngaged
		}
	}
	state GarmentToUser {
		initial i0

		final f0

		transition t0 {
			from i0
			to DetectStartPose
		}
		transition t2 {
			from DetectStartPose
			to Moving
			trigger 
		poseDetected
			action movementStart
		}
		state DetectStartPose {
			entry detectUserPose ( )
		}

		transition t1 {
			from Moving
			to f0
			trigger movementEnd
			action garmentWithUser = true
		}
		state Moving {
		}
	}
	state DressingLoop {
	initial i0
		state DetectUserPose {
			entry detectUserPose ( )
		}
		state MovingToJoint {
		}
		final f0
		transition t0 {
			from j0
			to DetectUserPose
			condition currentJoint > 0
			action currentJoint = currentJoint - 1
		}
		transition t1 {
			from i0
			to DetectUserPose
		}
		transition t2 {
			from DetectUserPose
			to MovingToJoint
			trigger 
			poseDetected
			condition currentJoint == 0 \/ currentJoint == 1 \/ currentJoint == 2
			action movementStart
		}
		transition t5 {
			from j0
			to f0
			condition currentJoint == 0
			action firstArmDressed = true
		}
		transition t7 {
			from FaultCheck
			to DetectUserPose
			trigger invalidPoseDetected
		}
		junction j0
		transition t6 {
			from MovingToJoint
			to FaultCheck
			trigger 
			movementEnd
		}
		state FaultCheck {
			entry checkFault ( )
		}
		state SnaggingCorrection {
		}
		transition t3 {
			from FaultCheck
			to SnaggingCorrection
			trigger snaggingDetected
		}
		transition t4 {
			from SnaggingCorrection
			to MovingToJoint
			action correctedMovement
		}
		transition t9 {
			from FaultCheck
			to j0
			action dressedJoint ! currentJoint
		}
	}

	transition t1 {
		from GarmentAcquisition
		to GarmentToUser
	condition garmentAcquired
	}
transition t2 {
		from GarmentToUser
		to DressingLoop
	condition garmentWithUser
	}
state s0 {
	}
transition t0 {
		from i0
		to s0
	}
	transition t3 {
		from s0
		to GarmentAcquisition
		trigger dressingRequest
	}
requires SensorOperations event dressedJoint : int
uses MovementEvents var garmentAcquired : boolean = false
	var garmentWithUser : boolean = false
var targetPosition : boolean
	var arrivedAtTarget : boolean = false
requires HRIOperations var isGripCorrect : boolean = false
	var isGripperEngaged : boolean = false
var firstArmDressed : boolean = false
	state SecondArm {
		initial i0
		state DetectSecondHand {
			entry detectSecondArm ( )
		}
		state ReleaseGrip {
			entry releaseGrip ( )
		}
		final f0
		state MovingToSecondHand {
		}
		state CheckingUserDressed {
			entry checkUserDressed ( )
		}
		transition t0 {
			from i0
			to DetectSecondHand
		}
		transition t1 {
			from ReleaseGrip
			to f0
		}
		transition t2 {
			from DetectSecondHand
			to MovingToSecondHand
			action movementStart
		}
		transition t3 {
			from MovingToSecondHand
			to CheckingUserDressed
			trigger movementEnd
		}
		transition t4 {
			from CheckingUserDressed
			to ReleaseGrip
			trigger userDressed
		}
	}
	transition t4 {
		from DressingLoop
		to SecondArm
		condition firstArmDressed
	}
}

//function A01(config: vector(real, 7)) : matrix(real, 4, 4) {
//	||cos(config[1]) 0 K1*sin(config[1]) a1*||
//}
module RobotAssistedDressing {
connection Franka on snaggingDetected to ctrl_ref0 on snaggingDetected ( _async )
	connection Franka on garmentDetected to ctrl_ref0 on garmentDetected ( _async )
	connection Franka on dressingRequest to ctrl_ref0 on dressingRequest ( _async )
	connection Franka on userInterrupt to ctrl_ref0 on userInterrupt ( _async )
	connection Franka on invalidPoseDetected to ctrl_ref0 on invalidPoseDetected ( _async )
	connection Franka on poseDetected to ctrl_ref0 on poseDetected ( _async )
	connection Franka on invalidTrajectory to ctrl_ref0 on invalidTrajectory ( _async )
	connection Franka on armConfig to ctrl_ref0 on armConfig ( _async )
	robotic platform Franka {
		uses DressingEvents provides FrankaArmControl uses EmergencyStopEvents provides SensorOperations uses EnvironmentalEvents provides HRIOperations event atTarget : boolean
		event dressedJoint : int
	}

	cref ctrl_ref0 = CDressingControl
connection Franka on userPosition to ctrl_ref0 on userPosition ( _async )
connection Franka on resumeDressing to ctrl_ref0 on resumeDressing ( _async )
	connection Franka on emergencyStop to ctrl_ref0 on emergencyStop ( _async )

	connection Franka on otherAgentDetected to ctrl_ref0 on otherAgentDetected ( _async )
	connection Franka on backgroundNoiseLevel to ctrl_ref0 on backgroundNoiseLevel ( _async )
connection Franka on gripCorrect to ctrl_ref0 on gripCorrect ( _async )
	connection Franka on gripperEngaged to ctrl_ref0 on gripperEngaged ( _async )
	connection Franka on atTarget to ctrl_ref0 on atTarget ( _async )
	connection ctrl_ref0 on dressedJoint to Franka on dressedJoint ( _async )
connection ctrl_ref0 on correctedMovement to Franka on correctedMovement ( _async )
connection Franka on secondHandDetected to ctrl_ref0 on secondHandDetected ( _async )
}

stm SEmergencyStopControl {
	uses EmergencyStopEvents initial i0
	state Running {
	}
	var emergencyStopped : boolean = false
	var environmentallyStopped : boolean = false
event allowMovement
event environmentalStop
	event environmentalResume
	transition t0 {
		from i0
		to Running
	}
	transition t1 {
		from Running
		to Running
		condition not emergencyStopped /\ not environmentallyStopped
		action allowMovement
	}
	transition t2 {
		from Running
		to Running
		trigger emergencyStop
		condition not emergencyStopped
		action emergencyStopped = true
	}
	transition t3 {
		from Running
		to Running
		trigger environmentalStop
		condition not environmentallyStopped
		action environmentallyStopped = true
	}
	transition t4 {
		from Running
		to Running
		trigger resumeDressing
		condition emergencyStopped
		action emergencyStopped = false
	}
	transition t5 {
		from Running
		to Running
		trigger environmentalResume
		condition environmentallyStopped
		action environmentallyStopped = false
	}
}

stm EnvironmentalMonitor {
	uses EnvironmentalEvents 
	var otherAgent : boolean
	event environmentalStop
	event environmentalResume
	initial i0
	state SensingHazard {
	}
	state OtherAgent {
	}
	state BackgroundNoise {
	}
	transition t0 {
		from i0
		to SensingHazard
	}
	transition t1 {
		from SensingHazard
		to OtherAgent
		trigger 
		otherAgentDetected ? otherAgent
		condition not otherAgent
		action environmentalResume
	}
	transition t2 {
		from OtherAgent
		to SensingHazard
		trigger 
		otherAgentDetected ? otherAgent
		condition otherAgent
		action environmentalResume
	}
	transition t3 {
		from SensingHazard
		to BackgroundNoise
		condition level == High
		action environmentalStop
	}
	transition t4 {
		from BackgroundNoise
		to SensingHazard
		condition level != NoiseLevel :: High
		action environmentalResume
	}
var level : NoiseLevel
}

stm MovementControl {
	uses MovementEvents requires FrankaArmControl var arrivedAtTarget : boolean = false
	event allowMovement
	event atTarget : boolean
	initial i0
	state NotEngaged {
	}
	state CheckMovement {
	}
	state MoveTowardsTarget {
		entry setConfiguration ( )
	}
	junction j0
	transition t0 {
		from i0
		to NotEngaged
	}
	transition t1 {
		from NotEngaged
		to CheckMovement
		trigger 
		movementStart
	}
	transition t2 {
		from CheckMovement
		to MoveTowardsTarget
		trigger allowMovement
	}
	transition t3 {
		from MoveTowardsTarget
		to j0
		trigger atTarget ? arrivedAtTarget
	}
	transition t4 {
		from j0
		to NotEngaged
		condition arrivedAtTarget
		action movementEnd
	}
	transition t5 {
		from j0
		to CheckMovement
		condition not arrivedAtTarget
	}
}

