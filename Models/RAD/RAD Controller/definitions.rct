package definitions

interface FrankaArmControl {
	stepTowards(target: vector(real, 3), speed: real)
	pushTowards(target: vector(real, 3), force: real)
	grip ( )
	releaseGrip ( )
setEEForces ( v : vector ( real , 3 ) )
	setEEPos ( v : vector ( real , 3 ) )
}

interface DressingEvents {
	event snaggingDetected
	event invalidTrajectory

	event invalidPoseDetected
	event userInterrupt

	event poseDetected : vector ( vector(real, 3) , 3 )
	event dressingRequest

	event garmentDetected : vector(real, 3)

	event armConfig

	event gripCorrect : boolean
	event gripperEngaged : boolean
event correctedMovement

	event secondHandDetected : vector(real, 3)
	event userDressed

}

interface SensorOperations {
	detectGarment ( )
detectUserPose ( )
checkFault ( )
detectSecondArm ( )
getEEPos ( )
}

interface EmergencyStopEvents {
	event emergencyStop

	event resumeDressing
	
	event collisionStop
	event collisionResume
}

interface EnvironmentalEvents {
	event backgroundNoiseLevel : NoiseLevel
	event otherAgentDetected : boolean
}

enumeration NoiseLevel { High Medium Low }

interface MovementEvents {
	event movementStart : vector(real, 3)
	event movementEnd

}

interface ForceEvents {
	event forceStart : vector(real, 3)
	event forceEnd
}

interface HRIOperations {
	checkCorrectGrip ( )
checkUserDressed ( )
}

interface FrankaArmEvents {
	event endEffectorPosition : vector(real, 3)
	event forceEndEffector: vector(real, 3)
}

function jointPosition(xs: vector(vector(real, 3), 3), i: int): vector(real, 3) {
	postcondition forall xxs: vector(vector(real, 3), 3), ii: int | ii >= 0 /\ ii < 3 @ jointPosition(xxs, ii) == xxs[ii]
}

function sqrt( a : real) : real {
	postcondition forall x : real | x > 0 @ sqrt ( x ) * sqrt ( x ) == x
}

function pow( x : real, i: nat ) : real {
	postcondition (forall x0 : real, i0: nat | i0 >= 0 @ pow (x0, i0 + 1) == pow(x0, i0)) /\ (forall x1 : real @ pow(x, 0) == 1)
}

function norm (p: vector(real, 3)): real {
	postcondition forall v: vector(real, 3)@ norm(v) == sqrt(pow(v[0], 2) + pow(v[1], 2) + pow(v[2], 2))
}

function scalarMul(s: real, v: vector(real, 3)): vector(real, 3) {
	postcondition forall ss: real, vv: vector(real, 3) @ scalarMul(ss, vv) == [|ss, ss, ss|] * vv
}

function targetForces(current : vector(real, 3), target: vector(real, 3), targetTotalForce: real): vector(real, 3) {
	postcondition forall c: vector(real, 3), t: vector(real, 3), ttf: real @ targetForces(c, t, ttf) == if norm(t - c) > 0 then (t - c) * (ttf / norm(t - c)) else [|0,0,0|] end
}

function dist ( p1 : vector(real, 3) , p2 : vector(real, 3) ) : real {
	postcondition forall v1: vector(real, 3), v2: vector(real, 3) @ dist ( v1 , v2 ) == norm(v1 - v2)
}

function gte (x: real, y: real): boolean {
	postcondition forall a: real, b: real @ gte(a, b) == (a >= b)
}